'''
https://www.acmicpc.net/problem/14500
- n이 500이니까 N^3 가능
- 완전탐색이구나
- 블록 경우의수 구해서 완전탐색으로 해결
겪은 문제
- 회전만 되고 대칭은 안 된다고 생각함
- 블럭을 일일히 회전한 좌표를 넣어 휴먼 에러 일으킴
코드 개선 및 검증
- nx = x + dx 로 코드 리팩토링, 기존에 튜플을 하나로 받아서 step[0], step[1] 로 했었음
- 기본 블럭 입력하고 rotate, 대칭 함수 만들어서 해결할 수 있을 것 같음
- 2차원 arr input 한 줄로 줄임, 리스트 컴프리헨션 활용해셔

'''

n, m = map(int, input().split())

block = [
  [(0, 0), (1, 0), (2, 0), (3, 0)],
  [(0, 0), (0, 1), (0, 2), (0, 3)],

  [(0, 0), (1, 0), (0, 1), (1, 1)],

  [(0, 0), (0, 1), (0, 2), (1, 2)],
  [(0, 0), (1, 0), (2, 0), (0, 1)],
  [(0, 0), (1, 0), (1, 1), (1, 2)],
  [(2, 0), (0, 1), (1, 1), (2, 1)],
  [(0, 0), (1, 0), (2, 0), (2, 1)],
  [(1, 0), (1, 1), (0,2), (1,2)],
  [(0,0), (0, 1), (1, 1), (2, 1)],
  [(0, 0), (1, 0), (0,1), (0, 2)],

  [(0, 0), (0, 1), (1, 1), (1, 2)],
  [(1, 0), (2, 0), (0, 1), (1, 1)],
  [(1, 0), (1,1), (0, 1), (0, 2)],
  [(0,0), (1, 0), (2, 1), (1, 1)],

  [(0, 0), (1, 0), (2, 0), (1, 1)],
  [(1, 0), (1, 2), (0, 1), (1, 1)],
  [(1, 0), (2, 1), (0, 1), (1, 1)],
  [(0, 0), (0, 2), (0, 1), (1, 1)],
]

# 전체 맵 정보를 입력받기
arr = [list(map(int, input().split())) for _ in range(n)]

res = 0

for y in range(n):
  for x in range(m):
    for b in block:
      sum = 0
      for dx, dy in b:
        nx = x + dx
        ny = y + dy
        if nx < 0 or nx >= m or ny < 0 or ny >= n:
          break
        sum += arr[ny][nx]
      if res < sum:
        res = sum

print(res)
